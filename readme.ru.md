# Queue

Queue это оболочка над Go каналами, которая имеет свойства:
* балансируемая
* с протечкой
* повторяемая
* планируемая
* с отложенным исполнением
* с механизмом метрик
* с логированием

Очередь была реализована в ответ на необходимость создания множества однотипных очередей, с одинаковыми свойствами.
Из раза в раз создавать одинаковые каналы с разными обработчиками было слишком скучно и в результате появилось это решение.

Queue позволяет абстрагироваться от деталей реализации самой очереди и сосредоточиться только на механизме обработки
элементов очереди. Достаточно написать реализацию обработчика, который реализует интерфейс [Worker](https://github.com/koykov/queue/blob/master/interface.go#L18),
привязать его к [конфигу](https://github.com/koykov/queue/blob/master/config.go#L22) очереди и она сама выполнит всю работу.

Queue не является классической очередью с двумя методами `Enqueue` и `Dequeue`. У этой реализации отсутствует метод
`Dequeue` и вместо него предлагается обработчик `Worker`. Очередь сама выполняет `dequeue` операцию и отправляет полученный
элемент одному из активных воркеров. Таким образом, можно положить элемент в очередь посредством вызова метода [Enqueue](https://github.com/koykov/queue/blob/master/interface.go#L6),
а далее очередь сама проверит есть ли доступный активный воркер, выполнит `dequeue` и отправит полученный элемент воркеру
на обработку. Такая реализация очереди реализует шаблон [Thread Pool](https://en.wikipedia.org/wiki/Thread_pool), но я
не слышал чтобы у этого шаблона было переменное количество потоков.

Очередь настраивается посредством заполнения структуры [Config](https://github.com/koykov/queue/blob/master/config.go#L22).
Двумя обязательными параметрами конфига являются `Size` и `Worker`.

Параметр `Size` задаёт размер очереди в элементах. Создать очередь без лимита по размеру нельзя.

Параметр `Worker` задаёт обработчик элементов очереди. Он должен реализовавыть интерфейс [Worker](https://github.com/koykov/queue/blob/master/interface.go#L18).
Воркер может только обработать элемент очереди и сообщить успешно он обработан или нет. Есть вспомогательный параметр
`Workers`, который задаёт количество воркеров, но он не является обязательным, т.к. настройка балансировки позволяет
очереди игнорировать этот параметр. Но если вы не хотите балансируемую очередь, то следует использовать этот параметр.

Под воркером подразумевается горутина (или возможность её запустить по необходимости, см. раздел "Балансировка"), внутри
которой работает объект обработчика.

В результате заполнения этих двух полей мы получим рабочую очередь с фиксированным размером, которая способна обработать
поступающие элементы.

Далее мы рассмотрим как включается и работает каждое из свойств очереди.

## Балансировка

Все очереди, с которыми я имел дело, имели переменную нагрузку. Днём она максимальная, а ночью сильно снижалась.
Приходилось всё время держать включёнными максимальное количество воркеров, хотя ночью было достаточно одного-двух
процентов от этого количества. В Go это не является проблемой, т.к. горутины весьма дёшевы, но решить задачу балансировки
количества воркеров в зависимости от нагрузки было слишком заманчивой идеей и я не нашёл причин не решить её.

Балансировка включается посредством задания параметров `WorkersMin` и `WorkersMax`, причём `WorkersMin` < `WorkersMax`.
Эти параметры не единственные, которые влияют на балансировку, но самые важные и их как правило достаточно.

`WorkersMin` задаёт количество перманентно активных воркеров. Вне зависимости от окружающих условий, количество активных
воркеров никогда не будет ниже этого значения.

`WorkersMax` ограничивает максимальное количество активных воркеров. Вне зависимости от условий работы, очередь не сможет
запустить больше чем `WorkersMax` воркеров. Подробнее что будет происходить в этом случае будет рассказано в разделе
"Протечка".

Все воркеры в промежутке между `WorkersMin` и `WorkersMax` могут находиться в трёх состояниях:
* активный - воркер работает и обрабатывает элементы очереди.
* спящий - воркер работает, но ничего не обрабатывает, т.к. в очереди нет достаточного количества элементов.
Это состояние воркера не является постоянным. Если в течении какого-то времени не повится доступных для обработки
элементов, то воркер перейдёт в неактивное состояние.
* неактивный - воркер (горутина) завершает работу. При необходимости очередь запустит новую горутину, в которой воркер 
займётся обработкой.

Очередь понимает, что пора запустить новый воркер в случае если [рейт](https://github.com/koykov/queue/blob/master/interface.go#L12)
очереди превышает параметр `WakeupFactor` [0..0.999999].
Можно взять к примеру очередь с размером 100 и `WakeupFactor` 0.5. В случае если в ней накопится больше 50-и элементов,
будет запущен новый воркер. Если и его будет недостаточно, то будет запущен ещё один. Таким образом очередь будет запускать
по одному воркеру пока рейт не станет меньше 0.5 (или не будет достигнут `WorkersMax`, см раздел "Протечка")

Далее предположим, что нагрузка на очередь спала и количество активных воркеров стало избыточным. В этом случае очередь
смотрит на параметр `SleepFactor` [0.0.999999] (причём `SleepFactor` < `WakeupFactor`). Если рейт очереди стал меньше
чем `SleepFactor`, то очередь переведёт один из активных воркеров в спящее состояние. Затем ещё один, если условие 
рейт < `SleepFactor` продолжает выполняться. Так будет продолжаться пока рейт не превысит `SleepFactor` или не будет
достигнут `WorkersMin`. Спящий воркер не будет находиться в таком состоянии вечно. Есть параметр (промежуток времени)
`SleepTimeout`, спустя который, если не повились элементы для обработки, воркер будет переведён в неактивное состояние
(горутина будет завершена). Спящее состояние необходимо для очередей, где нагрузка очень часто меняется. В таком случае
накладные расходы на создание/завершение горутин становится чувствительное. `SleepTimeout` позволяет буфферизировать эту
нагрузку.

Очередь постоянно балансирует количество воркеров таким образом, чтобы рейт находился в промежутке между `SleepFactor` и
`WakeupFactor`.
