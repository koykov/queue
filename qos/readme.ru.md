# QoS

QoS (Quality of Service) позволяет очереди приоретизировать элементы и обрабатывать их в порядке, определённом
алгоритмом приоретизации.

QoS использует под-очереди для приоретизации данных, каждая из которых является примитивной FIFO очередью. Элементы из
под-очередей, согласно алгоритму приоретизации, перемещаются в специальную выходную (egress) под-очередь.

## Использование

Для включения QoS необходимо заполнить параметр [`QoS`](https://github.com/koykov/queue/blob/master/config.go#L51) в
конфиге очереди:
```go
conf := Config{
	...
	QoS: &qos.Config{ ... } // или использовать qos.New(...)
	...
}
```

> Замечу, что заполнение этого параметра перезапишет параметр `Capacity` очереди суммой ёмкостей всех под-очередей. Это
единственный случай, когда можно создать очередь без указанной ёмкости.

## Настройка

### Алгоритм приоретизации

Параметр `Algo` позволяет задать из какой под-очереди будет взят очередной элемент для перемещения в egress под-очередь.
Сейчас доступны три алгоритма:
* `PQ` (Priority Queuing) - под-очередь, которая указана самой первой, будет обрабатываться в первую очередь, вторая
после того, как первая станет пустой, ...
* `RR` (Round-Robin) - из каждой под-очереди по очереди перемещается один элемент в egress.
* `WRR` (Weighted Round-Robin) - из под-очереди перемещается количество элементов пропорциональное её весу.

`DWRR` (Dynamic Weighted Round-Robin) алгоритм запланирован на будущее.

### Выходная (egress) очередь

`egress` это специальная под-очередь, куда перемещаются элементы согласно алгоритму приоретизации. Настраивается
посредством заполнения под-структуры `EgressConfig` с параметрами:
* `Capacity` - ёмкость, обязательный параметр.
* `Instances` - количество egress очередей для случаев, когда egress является бутылочным горлышком.
* `Workers` - количество воркеров, которые перемещают элементы в egress из прочих под-очередей.
* `IdleThreshold` - сколько попыток чтения допустимо предпринять из пустых под-очередей.
* `IdleTimeout` - сколько ждать после превышения `IdleThreshold` прежде чем предпринять ещё одну попытку чтения.

Каждый egress worker работает итерационно и перемещает один элемент за раз. Из какой под-очереди будет перемещаться
элемент зависит от алгоритма приоретизации (см параметр `Algo`). Если нет доступных для перемещения элементов, то
итерация будет считаться "холостой" (idle). После определённого числа idle итераций (см. `IdleThreshold`) воркер
заблокируется на определённое время (см. `IdleTimeout`). Воркер может разблокироваться раньше, если в очередь поступит
хоть один элемент.

### Приоретизатор

`Evaluator` реализует интерфейс `PriorityEvaluator` и позволяет "оценить" приоритет (в процентах) элемента.
В зависимости от этого приоритета, элемент будет направлен в одну из под-очередей, согласно её весу.

Из коробки доступны две реализации приоритезатора:
* [`Weighed`](https://github.com/koykov/queue/blob/master/priority/weighted.go) - для данных с характеристикой, которую
можно трактовать как "вес".
* [`Random`](https://github.com/koykov/queue/blob/master/priority/random.go) - тестовый приоритезатор, который выдаёт
случайный процент.

### Под-очереди

Параметр `Queues` позволяет задать произвольное количество под-очередей. Каждая очередь характеризуется тремя параметрами:
* `Name` - человекочитаемое имя, будет использоваться в метриках. Если его опустить, то будет использоваться индекс
под-очереди в списке `Queues`. Имена `ingress` и `egress` зарезервированы и не могут быть указаны.
* `Capacity` - ёймкость под-очереди в элементах. Обязательный параметр.
* `Weight` - вес под-очереди по умолчанию (в случае если не указаны `IngressWeight` и/или `EgressWeight`).
* `IngressWeight` - вес под-очереди для входящих элементов.
* `EgressWeight` - вес под-очереди для исходящих элементов.

Параметры `Weight`/`IngressWeight`/`EgressWeight` следует рассмотреть внимательнее. Этот вес по разному трактуется для
входящих и исходящих элементов:
* для входящих элементов это доля от процента приоритетности
* для исходящих элементов (только для weighted алгоритмов) доля пересылаемых в `egress` элементов.

Рассмотрим пример:
```go
qos.Config{
	Algo: qos.WRR,
	...
	Queues: []qos.Queue{
		{Name: "high", Capacity: 100, Weight: 250},   // ingress 25%; egress 1.6 (~2)	
		{Name: "medium", Capacity: 200, Weight: 600}, // ingress 60%; egress 4
		{Name: "low", Capacity: 700, Weight: 150},    // ingress 15%; egress 1
	}
}
```
Как этот элемент будет обработан QoS:
* при поступлении `Evaluator` посчитает его приоритет (процент)
* согласно проценту элемент будет направлен в соотвествующую очередь:
  * [0..25] - в первую
  * (25..60] - во вторую
  * (60..100] - в третью
* egress worker в течении ближайших 7 итераций пеместит в egress под-очереди (согласно пропорциям весов):
  * 2 элемента из первой очереди
  * 4 из второй
  * 1 из третьей

Это справедливо только для weighed алгоритмов QoS. Для `PQ` и `RR` исходящие элементы будут перемещаться без учёта
`Weight`, т.е. вес будет учитываться только для оценки приоритета входящих элементов.
